import React, { useRef, useState, useEffect } from "react";
import { LAYOUT } from "../lib/layout";

type SlideToConfirmProps = {
  onConfirm: () => void;
  disabled?: boolean;
  label?: string;
  className?: string;
};

export default function SlideToConfirm({
  onConfirm,
  disabled = false,
  label = "スライドして決済",
  className = "",
}: SlideToConfirmProps) {
  const trackRef = useRef<HTMLDivElement | null>(null);
  const knobRef = useRef<HTMLButtonElement | null>(null);
  const [dragging, setDragging] = useState(false);
  const [pos, setPos] = useState(0); // 0..1
  const [pointerId, setPointerId] = useState<number | null>(null);
  const [trackW, setTrackW] = useState(0);

  const knobPx   = LAYOUT.slideKnobPx;
  const confirmAt= LAYOUT.slideConfirmAt;
  const insetL   = LAYOUT.slideInsetStartPx;
  const insetR   = LAYOUT.slideInsetEndPx;

  const maxRange = Math.max(0, trackW - knobPx - insetL - insetR);

  useEffect(() => {
    const updateW = () => setTrackW(trackRef.current?.clientWidth || 0);
    updateW();
    window.addEventListener("resize", updateW);
    return () => window.removeEventListener("resize", updateW);
  }, []);

  const clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(max, v));
  const updateByClientX = (clientX: number) => {
    if (!trackRef.current) return;
    const rect = trackRef.current.getBoundingClientRect();
    const rel = clamp(clientX - (rect.left + insetL), 0, maxRange);
    setPos(rel / (maxRange || 1));
  };

  useEffect(() => {
    const onPointerMove = (e: PointerEvent) => {
      if (!dragging) return;
      e.preventDefault(); e.stopPropagation();
      updateByClientX(e.clientX);
    };
    const onPointerUp = (e: PointerEvent) => {
      if (!dragging) return;
      e.preventDefault(); e.stopPropagation();
      if (pointerId !== null && knobRef.current?.hasPointerCapture(pointerId)) {
        knobRef.current.releasePointerCapture(pointerId);
      }
      setDragging(false);
      if (pos >= confirmAt && !disabled) {
        setPos(1);
        onConfirm();
      } else {
        setPos(0);
      }
    };

    window.addEventListener("pointermove", onPointerMove, { passive: false });
    window.addEventListener("pointerup", onPointerUp, { passive: false });
    return () => {
      window.removeEventListener("pointermove", onPointerMove);
      window.removeEventListener("pointerup", onPointerUp);
    };
  }, [dragging, pos, disabled, onConfirm, pointerId, maxRange]);

  const startDrag = (e: React.PointerEvent) => {
    e.preventDefault(); e.stopPropagation();
    setDragging(true);
    setPointerId(e.pointerId);
    knobRef.current?.setPointerCapture(e.pointerId);
    updateByClientX(e.clientX);
  };

  const knobLeftPx = insetL + pos * maxRange;
  const fillW = Math.max(knobLeftPx + knobPx, knobPx); // ノブ端まで塗る

  return (
    <div className={"w-full select-none " + (disabled ? "opacity-50 pointer-events-none " : "") + (className || "")}>
      <div
        ref={trackRef}
        className="relative h-11 w-full rounded-full bg-gradient-to-b from-white to-neutral-100 ring-1 ring-black/10 shadow-sm overflow-hidden"
        aria-label={label}
      >
        {/* ラベル */}
        <div className="absolute inset-0 flex items-center justify-center text-neutral-600 pointer-events-none" style={{ fontSize: LAYOUT.slideLabelPx }}>
          {label}
        </div>

        {/* 進捗 */}
        <div
          className="absolute top-0 left-0 h-full bg-neutral-200/50"
          style={{ width: fillW }}
        />

        {/* ノブ */}
        <button
          ref={knobRef}
          type="button"
          className="absolute top-1/2 -translate-y-1/2 rounded-full bg-gradient-to-b from-white to-neutral-200 shadow ring-1 ring-black/10 ui-tap ui-focus"
          style={{ width: knobPx, height: knobPx, left: knobLeftPx }}
          onPointerDown={startDrag}
          aria-label={label}
        />
      </div>
    </div>
  );
}
